# 12 月前端面试复盘

:::
最近离职后开启了复习和面试模式，这里记录一下面试问到的问题
:::

## 字节跳动飞书一面（通过）

### 自我介绍+聊项目 (10min)

- **低代码平台如何解决源码更新的发版问题**

  - 通过操作规范和 CICD 约束流程，发 npm 包->更新渲染器->升级运行态应用->更新物料

- **低代码平台适用于公司的哪些业务**

  - PC：重复的表单表格业务

  - 移动端：轻交互轻逻辑的小程序页面（海报, 营销活动, 问卷表单）

- **如何理解在低代码平台分发后在几条业务线并行开发**

  - 项目通过镜像的方式发布应用市场，持续提供版本号给各个业务线，同时业务线也在使用过程中提 PR

  - 平台支持业务线接入自己的组件库，渲染引擎提供主流程的能力，方便横向扩展应用能力

（面试官更关心项目发版和更新的流程）

### 技术问题 (30min)

- **JS 的类型和区别**

  - 基本类型

  - 引用类型

  - 栈内存和堆内存

- **JS 的不同类型在函数里面调用时区别**

  - 函数上下文

  - 形参和实参的关系

- **let 和 var 的区别**

  - 块级作用域（词法环境）

  - 变量提升

- **追问：哪些情况会发生上下文的提升**

  - 函数和变量的提升，以及提升范围

- **追问：function 和 var 发生提升的优先级哪个更高**

  - 函数和变量提升方式的差异

- **如何理解闭包**

  - 函数上下文

  - 模块化，自由变量

  - GC

- **追问：函数作用域是什么时候创建的**

  - 定义时创建

  - JS 的词法环境

- **有没有了解过 CDN**

  - DNS 的代理和递归

  - 分布式和负载均衡

  - 浏览器缓存

- **说一下重绘和回流**

  - 浏览器的渲染过程

  - CSS 属性发生作用的不同阶段

- **追问：什么情况触发回流，回流的的影响范围**

  - 触发回流的条件：style 更改了布局属性、js 访问了模型布局属性

- **说一下对 BFC 的了解**

  - 浏览器的布局原理

  - 块级格式化上下文的创建条件

- **CSS 选择器的优先级，在项目中如何避免选择器的冲突**

  - CSS 样式的计算过程，层叠规范（id>class>media query>:伪类>类型）

  - CSS 的一些架构规范：例如 SMACSS、Module、ACSS

- **浏览器的储存方式有哪些**

  - 联系到浏览器 API，4 种常见的储存方式，需要说出区别

- **说一下接口的缓存方式**

- **有没有了解过 BOM**

  - 基本上在浏览器上不属于 EcmaScript 规范的都是跟 BOM 相关的 API

  - 需要说出常见浏览器对象和 API

  - 对象：window, navigator, screen, history, location, FileReader, XMLHttpRequest, IntersectionObserver, MutationObserver, Worker

  - API：postMessage、fetch

### 手写代码 (20min)

- **Promise 和 async/await、setTimeout 混写的代码，写出输出结果**

- **二叉树的蛇形遍历**

  - 思路：层序遍历 + 打印结果按 flag 状态进行一个交替输出

- **封装一个发布订阅事件处理器，实现 on、off、once、emit**

  就是关于事件队列的维护，但是我准备的时候没有考虑到一种**复杂**的情况：

  ```js
  let fn = () => {
    console.log(1)
  }
  event.once('event1', fn)
  event.off('event1', fn)
  event.emit('event1') // 无输出
  ```

  由于 once 是借助闭包封装了一个新的函数，事件队列里面记录的是新函数的指针

  导致调用 off 的时候传原函数是找不到的，也就没法清空

  这里提供 2 个思路

  1. once 的时候直接用新的函数覆盖原函数指针（但我觉得这种方式不好，因为影响了原来的函数，有副作用）

  2. once 的时候给 fn 加一个属性，指向重新创建的代理函数，这样就可以在 off 的时候把代理函数也干掉（更优，加属性影响范围很小，甚至加的属性可以用 symbol 和业务避免冲突）

---

## 字节跳动飞书二面（卒）

### 自我介绍+聊项目（30min）

- **做低代码平台的时候有没有参考其它公司的开源项目，比如阿里的低代码引擎，他的**协议**设计和你们的差异是什么**

  - 确实是没有深入了解，因为规范是架构师定的，要求我们要自研，满足自身的业务需要

  - 回答方向上应该从优先满足业务的角度考虑，另外确实要参考一下开源项目的方案

    - 1. 因为低代码平台还包括了后端的物料，需要同时兼容后端的物料格式

    - 2. 需要承接已有的物料格式

    - 3. 我们的低代码平台没有阿里的复杂，物料格式上需要进行简化

    - 4. 需要满足自身的业务需求，例如无限嵌套，因此在协议上需要有自主权

- **介绍一下物料的数据**协议**和页面的数据**协议**如何设计的**

  - 物料：基本信息（编码、来源：源码 or 低码） + 配置信息（表单 dsl） + 默认属性

  - 页面：

    - 容器信息：页面名称、页面版本、变量字典（默认值用 json string）、物料字典（页面用到的组件的编码+来源）

    - 元素信息：基本信息（编码、uid、索引、版本） + 组件属性

- **为什么不使用开源项目的设计规范，而是选择自己定义**

  - 业务需要，但是有参考开源项目的设计思路

- **如何解决多人同时编辑的冲突问题，比如动态代码编译后变成一行后，多人同时修改的冲突**

  - 业务方案：1. 编辑锁；2. 页面拆小模块，对应的人改对应的模块，模块通过后端拼凑成页面

  - 技术方案：后端进行 JSON diff，可以解决增、删、移动问题，但是具体到行改动的问题只能后面覆盖前面

- **展示组件能否实现嵌套**

  - 组件划分：嵌套只能由容器组件提供

  - 需求实现：对于场景上的需要（封装卡片组件，标题+内容），由自定义组件提供插槽

- **如何通过容器组件和展示组件实现一个列表**

  - 考虑到了这个问题，提供了列表容器按数据源循环出子容器，接收展示组件，循环渲染出来

  - 列表子组件的数据接收是通过定义 dsl 获取容器循环的执行上下文

- **低代码渲染器前端的性能问题如何解决**

  - 分阶段考虑问题

    - 1. 请求阶段：

      - 可以通过 JSON 的压缩算法减少体积(json-pack)

      - 可以通过版本号和客户端储存的方式提高二次进入的加载速度

    - 2. 渲染阶段：

      - 可以通过时间分片(requestIdleCallback)，让组件分批次地出来，类似于懒加载，同时不阻塞交互。

      - 组件分批次的依据，可以在编辑器保存时事先分组，并将分组信息保存到数据上，因为组件已经渲染出来了，知道位置。（也可以借助服务端调无头浏览器自动化分组，反正生成截图的时候都要用到的）

  - 其它角度

    - 1. 骨架屏（也可以通过编辑器或服务端生成）

    - 2. 减少节点数量的思路，对于很复杂的组件，考虑用一个大组件写源码实现，从而减少渲染器的负担。

- **表单项的关联更新和隐藏是如何设计的**

  - 我们的方案是在单个表单项通过 mutex（互斥）的编排（定义 id 和互斥逻辑），定义表单项之间的关系，把互斥的表单项从表单的 UI 和数据中都剔除掉。

- **动态代码的线上问题如何定位和排查**

  - 1. 给动态代码的调用入口增加了 try catch，可以精准定位错误位置，甚至可以 debug

  - 2. 小程序提供了简易的动作编排配置，本质还是走源码逻辑，不会提供动态代码的方案

- **说一下变量管理为什么不使用 React 的 state，而是自己做依赖收集**

  - 1. 我们定义的变量是挂载到容器上的，而不是变量上的，实际上还是利用了 state，但是 state 会通过 context 传递到每一个组件上，导致了每次状态的变更都会触发全量的重渲染

  - 2. 出于性能优化的需要，我们需要建立组件属性和容器状态的关联，进行细粒度更新

  - 3. 依赖收集的方式和 Vue3 类似，是发布订阅的设计模式，跟踪到具体状态的变化通知对应的组件更新

- **如何实现组件的动态化，属性随着接口数据变化**

  - 我们的框架是重运行时的，编辑器的编排就是为了定义变量、接口和组件的关联

  - 在编辑器上，定义接口的响应关联到变量 key 上

  - 变量更新驱动了视图的更新

（面试官更关心项目的选型依据，以及业务问题的思考方向和解决思路）

### 手写代码（20min）

- **走二维迷宫，根据随机的起点和终点判断有没有解**

原题是二维数组中有 0 和 1 组成的迷宫，1 是墙，随机给起点和终点判断能不能走出去，例如

[
[0, 1, 0, 1]
[0, 1, 0, 0]
[0, 1, 1, 0]
[0, 0, 0, 0]
]
起点：[0, 0]，终点：[0, 3]

我在 leetcode 没有找到一样的，但是有一道类似的

![字母迷宫](./lcr-129.png)

这是一道 dfs 的算法题，但是其实还多了回溯过程，这是我当时通过迭代法只做了暴力解法

没有考虑到回溯去优化，这里通过这道题复盘一下

```js
/**
 * @param {character[][]} grid
 * @param {string} target
 * @return {boolean}
 */
const wordPuzzle = function (grid, target) {
  let rows = grid.length
  let cols = grid[0].length
  const dfs = (i, j, k) => {
    // 终止条件1：越界了或者不等于目标值
    // 这里最后一个判断很关键【我面试的时候未考虑到】，就是即使走对了，也会把grid[i][j]改成\0，从而让条件false，从而避免了走重复的路径，保证前进的方向始终是不重复的
    if (i >= rows || i < 0 || j >= cols || j < 0 || grid[i][j] !== target[k])
      return false
    // 终止条件2：成功走到了终点
    if (k === target.length - 1) return true
    // 记录走过的路径
    grid[i][j] = '\0'
    // 按右，左，上，下的顺序开始走迷宫
    let res =
      dfs(i + 1, j, k + 1) ||
      dfs(i - 1, j, k + 1) ||
      dfs(i, j + 1, k + 1) ||
      dfs(i, j - 1, k + 1)
    // 不管命中了true还是false，都记录一下当前的路径
    grid[i][j] = target[k]
    return res
  }
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      // 遍历所有的格子，开始走迷宫
      // dfs一直「递」到终点然后走「归」的流程让结果冒泡到这里
      if (dfs(i, j, 0)) {
        return true
      }
    }
  }
  return false
}
```

### 开放性问题（10min）

（开放题我没怎么准备，同时也因为时间关系，最后十分钟没聊好 😭）

- **有没有关注一些新技术**

  - 提到了最近比较关注 SSR 和 CSR

  - 一时没想起来的：monorepo、esbuild、PWA、electron、threejs-xr

  - 我所了解的前端的趋势：

    - PWA 的回归（现在后管项目动辄几十 M，后管可以提供 PWA 的方式，借助本地离线包，提高用户的加载体验），safari 和 chrome 都提供了这种形式，达到接近原生桌面端应用的体验

    - 随着 Node.js 的发展，前后端的界限可能会被重新抹平（Vue 和 React 都有推 SSR 专用模块），从而让前端在服务端渲染阶段通过 SQL 直接获取数据。所以前端也需要学习数据库

    - 随着浏览器进一步开放 wasm 和 worker，性能会得到极大的提升，JS 单线程的性能瓶颈会得到较大的释放，社区有传言 React 想用 Rust 重构 Fiber 模块。

    - 随着增强现实（XR）技术的发展，未来 threejs 可能是一个大方向，网页可能会以 3d 的方式渲染，交互方式和布局方式都会发生比较大的变革，不再受画布边界的限制。希望学习一下 threejs 和 threejs-xr

- **最近在研究什么技术，以及学习的方式**

  - 正在学习 tdd 的思路，并且通过这种思路去实现一些框架的主流程，从而训练自己的思维

  - 学习的方式：官方文档、掘金优质文章、字节前端公众号、github 源码

- **在以前的公司有没有开展什么技术分享**

  - 有组织技术分享，担任主讲，手撕框架源码

  - 有沉淀技术文档和开发文档

---

## 豌豆思维一面（通过）

### 自我介绍+聊项目（20min）

...略过重复问题

- **低代码页面的性能优化怎么做的，有什么判定指标，如何监控**

[网页性能优化指标](../frontend/浏览器/网页性能优化指标.md)

（整体感觉：面试官更注重项目的性能和发版流程）

### 技术问题（10min）

- **package-lock 的作用**

  - 是什么：npm 装依赖自动生成的文件，用于确保在不同的环境中安装相同版本的依赖包，以保持项目的一致性

  - 具体流程：

    - 1. 符合范围，以锁死的版本号为主

    - 2. 不符合范围，将按 package.json 的版本安装，并覆盖 lock 配置

- **追问：什么情况下不能锁定版本**

  - 场景举例：

    - 1. 持续集成或持续交付环境，希望**始终使用最新**的稳定版包依赖

    - 2. 多人协作场景，团队成员的系统环境和 Node 环境不一样，锁定版本可能会导致冲突

    - 3. 需要降低依赖版本的场景，locked 文件可能会阻止这样的调整

    - 4. 信任包作者，希望让包依赖获取最新的支持

  - 防止锁定的方式：

    - 1. `install`的时候加上`--no-lockfile`可以防止生成 lock 文件

    - 2. 加到`.gitignore`防止提交

  - 危害：

    - 可能会导致不同环境安装的依赖版本不一致，依赖本身导致的 bug 不好排查

- **package.json 的 scripts 运行脚本和 node 运行脚本有什么区别**

  - 运行环境的区别：package.json 的 script 在项目上下文中执行，node 命令在系统环境运行（不会考虑项目依赖关系）

  - 依赖管理的区别：script 脚本可以直接使用 node_modules 的依赖，node 只能使用全局依赖

  - 命令的命名和管理：script 可以更好地约定项目命令，node 则每次都需要手敲

- **node 文件中执行 require 会发生什么**

  - 1. 查找模块

    - 先找核心模块：例如 fs、http

    - 再找路径模块，按绝对路径或相对路径找

    - 第三方模块，沿着文件路径向上逐级找 node_modules 目录（每层都会看有没有 node_modules）

    - NODE_PATH 环境变量

  - 2. 加载模块

    - 一旦找到模块文件，Node 会将文件加载到内存中，如果是 js 文件，会被解释执行，如果是 JSON 文件，会被解析为对象，如果是二进制模块，会被直接加载

  - 3. 缓存模块

    - Node 会缓存 require 过的模块，以便在后序 require 中直接返回缓存的模块，确保模块只会被加载一次，变量也不会重复创建。

  - 4. 返回模块结果

    - require 的结果是加载模块的结果，可以是对象、函数、类、或者其他可到处的项，具体取决于被加载模块的内容

- **你们项目的 http 缓存采用什么策略**

  - 文件指纹

  - 强缓存和协商缓存，尽量使用协商缓存

  - 版本号路径（类似于指纹）

  - 服务端配置缓存策略

### 反问（5min）

- **项目上会有哪些挑战**

  - 涉及的技术栈比较多，React、Vue、Eletron，也有低代码平台

- **开发节奏怎么样**

  - 看业务线，有些业务线是按迭代的，有些是分配任务的

- **团队氛围怎么样**

  - 前端团队有 12 个人，会定期组织代码 review 和技术分享（每月 2 次）

---

## 豌豆思维二面

整体聊下来感觉挺不错的，面试官很随和，没有 pua

### 自我介绍+聊项目

略过重复问题...

- **项目上做了哪些体验上的优化**

  - 通过自定义组件的定制配置，隔离了开发者和运营者的可控范围

  - 限制了运营者界面的可控操作，简化整体流程

- **低代码的页面发布到生产环境的流程是怎样的**

  - 首先编辑完之后可以通过我们提供的二维码和 url 进行预览

  - 【1】未搭建的页面可以保存为草稿

  - 【2】保存后进入页面库，但是处于预发布的状态

  - 【3】需要在列表上点击发布按钮，才会最终去到线上

- **前端的错误监控体系怎么做的**

  - 通过 ReactErrorBoundary 埋点，同时隐藏掉报错的模块，把影响范围降到最小

  - 同时组件出现了问题也可以把在页面上把组件回滚到上一个版本，或者页面整体回滚到上一个版本先进行上线

  - 把错误信息通过接口进行上报（包含了出错的页面信息）

  - 后端通过钉钉机器人在支撑群里报警

- **低代码项目如果线上出了问题，说一下你们从排查到修复的流程**

  - 通过钉钉机器人得到的报警信息或者测试的信息，包含了页面 json 数据、版本信息和应用信息

  - 前端值班人员根据 json 数据本地 mock 出错误情况进行分析、修复和上线

  - 项目发版后将更新版本号和 bug 信息通知到对应的人员（最快半小时内）

- **你们团队有多少个人在做这个项目**

  - 4 个人，我主要负责低代码平台的主流程，其他人配合写一些插件和 UI 组件

  - 低代码组件和业务组件的开发会分发到对应业务线的同学进行开发，我们会进行相应的培训

- **项目上遇到最大的挑战是什么**

  - 技术挑战：编辑器和表单的性能优化

  - 管理挑战：推动业务线去使用低代码平台

（整体感觉：面试官更注重项目的用户体验和稳定性，侧重监控体系和性能指标，其实大部分问题和一面重复）

### 反问

- **团队是只关注业务还是会有前端基建和技术创新**

  - 有基础设施团队

  - 会根据各个业务线擅长的领域安排抽象一些通用模块和组件

- **项目开发节奏怎么样，是否一直在追赶上线**

  - 会根据公司需求安排工作，有时候闲有时候忙
