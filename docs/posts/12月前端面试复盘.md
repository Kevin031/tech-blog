# 12 月前端面试复盘

:::
最近离职后开启了复习和面试模式，这里记录一下面试问到的问题
:::

## 字节一面（通过）

### 自我介绍+聊项目

- 低代码平台如何解决源码更新的发版问题

  - 通过操作规范和 CICD 约束流程，发 npm 包->更新渲染器->升级运行态应用->更新物料

- 低代码平台适用于公司的哪些业务

  - PC：重复的表单表格业务

  - 移动端：轻交互轻逻辑的小程序页面（海报, 营销活动, 问卷表单）

- 如何理解在低代码平台分发后在几条业务线并行开发

  - 项目通过镜像的方式发布应用市场，持续提供版本号给各个业务线，同时业务线也在使用过程中提 PR

  - 平台支持业务线接入自己的组件库，渲染引擎提供主流程的能力，方便横向扩展应用能力

### 技术问题

- JS 的类型和区别

  - 基本类型

  - 引用类型

  - 栈内存和堆内存

- JS 的不同类型在函数里面调用时区别

  - 函数上下文

  - 形参和实参的关系

- let 和 var 的区别

  - 块级作用域（词法环境）

  - 变量提升

- 追问：哪些情况会发生上下文的提升

  - 函数和变量的提升，以及提升范围

- 追问：function 和 var 发生提升的优先级哪个更高

  - 函数和变量提升方式的差异

- 如何理解闭包

  - 函数上下文

  - 模块化，自由变量

  - GC

- 追问：函数作用域是什么时候创建的

  - 定义时创建

  - JS 的词法环境

- 有没有了解过 CDN

- 说一下重绘和回流

  - 浏览器的渲染过程

  - CSS 属性发生作用的不同阶段

- 追问：什么情况触发回流，回流的的影响范围

  - 触发回流的条件：style 更改了布局属性、js 访问了模型布局属性

- 说一下对 BFC 的了解

  - 浏览器的布局原理

  - 块级格式化上下文的创建条件

- CSS 选择器的优先级，在项目中如何避免选择器的冲突

  - CSS 样式的计算过程，层叠规范（id>class>media query>:伪类>类型）

  - CSS 的一些架构规范：例如 SMACSS、Module、ACSS

- 浏览器的储存方式有哪些

  - 联系到浏览器 API，4 种常见的储存方式，需要说出区别

- 说一下接口的缓存方式

- 有没有了解过 BOM

  - 基本上在浏览器上不属于 EcmaScript 规范的都是跟 BOM 相关的 API

  - 需要说出常见浏览器对象和 API

  - 对象：window, navigator, screen, history, location, FileReader, XMLHttpRequest, IntersectionObserver, MutationObserver, Worker

  - API：postMessage、fetch

### 手写代码

- Promise 和 async/await、setTimeout 混写的代码，写出输出结果

- 二叉树的蛇形遍历

  - 思路：层序遍历 + 打印结果按 flag 状态进行一个交替输出

- 封装一个发布订阅事件处理器，实现 on、off、once、emit

  就是关于事件队列的维护，但是我准备的时候没有考虑到一种**复杂**的情况：

  ```js
  let fn = () => {
    console.log(1)
  }
  event.once('event1', fn)
  event.off('event1', fn)
  event.emit('event1') // 无输出
  ```

  由于 once 是借助闭包封装了一个新的函数，事件队列里面记录的是新函数的指针

  导致调用 off 的时候传原函数是找不到的，也就没法清空

  这里提供 2 个思路

  1. once 的时候直接用新的函数覆盖原函数指针（但我觉得这种方式不好，因为影响了原来的函数，有副作用）

  2. once 的时候给 fn 加一个属性，指向重新创建的代理函数，这样就可以在 off 的时候把代理函数也干掉（更优，加属性影响范围很小，甚至加的属性可以用 symbol 和业务避免冲突）

## 字节二面

### 自我介绍+聊项目

- 做低代码平台的时候有没有参考其它公司的开源项目，比如阿里的低代码引擎，他的**协议**设计和你们的差异是什么

  - 确实是没有深入了解，因为规范是架构师定的，要求我们要自研，满足自身的业务需要

  - 回答方向上应该从优先满足业务的角度考虑，另外确实要参考一下开源项目的方案

- 介绍一下物料的数据**协议**和页面的数据**协议**如何设计的

  - 物料：基本信息（编码、来源：源码 or 低码） + 配置信息（表单 dsl） + 默认属性

  - 页面：

    - 容器信息：页面名称、页面版本、变量字典（默认值用 json string）、物料字典（页面用到的组件的编码+来源）

    - 元素信息：基本信息（编码、uid、索引、版本） + 组件属性

- 为什么不使用开源项目的设计规范，而是选择自己定义

  - 业务需要，但是有参考开源项目的设计思路

- 如何解决多人同时编辑的冲突问题，比如动态代码编译后变成一行后，多人同时修改的冲突

  - 业务方案：1. 编辑锁；2. 页面拆小模块，对应的人改对应的模块，模块通过后端拼凑成页面

  - 技术方案：后端进行 JSON diff，可以解决增、删、移动问题，但是具体到行改动的问题只能后面覆盖前面

- 展示组件能否实现嵌套

  - 组件划分：嵌套只能由容器组件提供

  - 需求实现：对于场景上的需要（封装卡片组件，标题+内容），由自定义组件提供插槽

- 如何通过容器组件和展示组件实现一个列表

  - 考虑到了这个问题，提供了列表容器按数据源循环出子容器，接收展示组件，循环渲染出来

  - 列表子组件的数据接收是通过定义 dsl 获取容器循环的执行上下文

- 低代码渲染器前端的性能问题如何解决

  - 分阶段考虑问题

    - 1. 请求阶段：

      - 可以通过 JSON 的压缩算法减少体积(json-pack)

      - 可以通过版本号和客户端储存的方式提高二次进入的加载速度

    - 2. 渲染阶段：

      - 可以通过时间分片(requestIdleCallback)，让组件分批次地出来，类似于懒加载，同时不阻塞交互。

      - 组件分批次的依据，可以在编辑器保存时事先分组，并将分组信息保存到数据上，因为组件已经渲染出来了，知道位置。（也可以借助服务端调无头浏览器自动化分组，反正生成截图的时候都要用到的）

  - 其它角度

    - 1. 骨架屏（也可以通过编辑器或服务端生成）

    - 2. 减少节点数量的思路，对于很复杂的组件，考虑用一个大组件写源码实现，从而减少渲染器的负担。

- 表单项的关联更新和隐藏是如何设计的

  - 我们的方案是在单个表单项通过 mutex（互斥）的编排（定义 id 和互斥逻辑），定义表单项之间的关系，把互斥的表单项从表单的 UI 和数据中都剔除掉。

- 动态代码的线上问题如何定位和排查

  - 1. 给动态代码的调用入口增加了 try catch，可以精准定位错误位置，甚至可以 debug

  - 2. 小程序提供了简易的动作编排配置，本质还是走源码逻辑，不会提供动态代码的方案

- 说一下变量管理为什么不使用 React 的 state，而是自己做依赖收集

  - 1. 我们定义的变量是挂载到容器上的，而不是变量上的，实际上还是利用了 state，但是 state 会通过 context 传递到每一个组件上，导致了每次状态的变更都会触发全量的重渲染

  - 2. 出于性能优化的需要，我们需要建立组件属性和容器状态的关联，进行细粒度更新

  - 3. 依赖收集的方式和 Vue3 类似，是发布订阅的设计模式，跟踪到具体状态的变化通知对应的组件更新

- 如何实现组件的动态化，属性随着接口数据变化

  - 我们的框架是重运行时的，编辑器的编排就是为了定义变量、接口和组件的关联

  - 在编辑器上，定义接口的响应关联到变量 key 上

  - 变量更新驱动了视图的更新

### 手写代码

- 走二维迷宫，根据随机的起点和终点判断有没有解

原题是二维数组中有 0 和 1 组成的迷宫，1 是墙，随机给起点和终点判断能不能走出去，例如

[
[0, 1, 0, 1]
[0, 1, 0, 0]
[0, 1, 1, 0]
[0, 0, 0, 0]
]
起点：[0, 0]，终点：[0, 3]

我在 leetcode 没有找到一样的，但是有一道类似的

![字母迷宫](./lcr-129.png)

这是一道 dfs 的算法题，但是其实还多了回溯过程，这是我当时通过迭代法只做了暴力解法

没有考虑到回溯去优化，这里通过这道题复盘一下

```js
/**
 * @param {character[][]} grid
 * @param {string} target
 * @return {boolean}
 */
const wordPuzzle = function (grid, target) {
  let rows = grid.length
  let cols = grid[0].length
  const dfs = (i, j, k) => {
    // 终止条件1：越界了或者不等于目标值
    // 这里最后一个判断很关键【我面试的时候未考虑到】，就是即使走对了，也会把grid[i][j]改成\0，从而让条件false，从而避免了走重复的路径，保证前进的方向始终是不重复的
    if (i >= rows || i < 0 || j >= cols || j < 0 || grid[i][j] !== target[k])
      return false
    // 终止条件2：成功走到了终点
    if (k === target.length - 1) return true
    // 记录走过的路径
    grid[i][j] = '\0'
    // 按右，左，上，下的顺序开始走迷宫
    let res =
      dfs(i + 1, j, k + 1) ||
      dfs(i - 1, j, k + 1) ||
      dfs(i, j + 1, k + 1) ||
      dfs(i, j - 1, k + 1)
    // 不管命中了true还是false，都记录一下当前的路径
    grid[i][j] = target[k]
    return res
  }
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      // 遍历所有的格子，开始走迷宫
      // dfs一直「递」到终点然后走「归」的流程让结果冒泡到这里
      if (dfs(i, j, 0)) {
        return true
      }
    }
  }
  return false
}
```

### 开放性问题

（开放题我没怎么准备，同时也因为时间关系，最后十分钟没聊好 😭）

- 有没有关注一些新技术

  - 提到了最近比较关注 SSR 和 CSR

  - 一时没想起来的：monorepo、esbuild、PWA、electron、threejs-xr

  - 我所了解的前端的趋势：（如果有机会 3 面，还是可以聊一下这几个角度）

    - PWA 的回归（现在后管项目动辄几十 M，后管可以提供 PWA 的方式，借助本地离线包，提高用户的加载体验），safari 和 chrome 都提供了这种形式，达到接近原生桌面端应用的体验

    - 随着 Node.js 的发展，前后端的界限可能会被重新抹平（Vue 和 React 都有推 SSR 专用模块），从而让前端在服务端渲染阶段通过 SQL 直接获取数据。所以前端也需要学习数据库

    - 随着浏览器进一步开放 wasm 和 worker，性能会得到极大的提升，JS 单线程的性能瓶颈会得到较大的释放，社区有传言 React 想用 Rust 重构 Fiber 模块。

    - 随着增强现实（XR）技术的发展，未来 threejs 可能是一个大方向，网页可能会以 3d 的方式渲染，交互方式和布局方式都会发生比较大的变革，不再受画布边界的限制。希望学习一下 threejs 和 threejs-xr

- 最近在研究什么技术，以及学习的方式

  - 正在学习 tdd 的思路，并且通过这种思路去实现一些框架的主流程，从而训练自己的思维

  - 学习的方式：官方文档、掘金优质文章、字节前端公众号、github 源码

- 在以前的公司有没有开展什么技术分享

  - 有组织技术分享，担任主讲，手撕框架源码

  - 有沉淀技术文档和开发文档
