# 面试八股文大纲

以下题目仅描述思路

## 语言原理

### JS

1. **0.1+0.2==0.3 吗，为什么？**

小数进制转换和对阶运算导致的精度丢失。解决思路：通过字符串自己实现运算逻辑，或者在小数位已知的前提下转换成整数运算。

2. JS 数据类型

基本类型：Number, Boolean, String, null, undefined, symbol, BigInt

引用类型：Object（对象子类型 Array, Function, Map, Set）

3. 如何实现对象深拷贝？

遍历对象，object 类型执行递归，基本类型直接赋值。

进阶：需考虑循环引用、函数、时间等类型

4. new 一个函数发生了什么？

创建一个新对象，新对象的`__proto__`指向构造函数 `prototype` 所引用的对象，新对象绑定函数的 `this`，如果函数没有返回值，就直接返回这个新对象

```js
function myNew(func, args) {
  // 1.新建一个空对象
  let obj = new Object();
  // 2.将构造函数的prototype指向新对象的__proto__
  obj.__proto__ = fun.prototype;
  // 3.改变this的指向（在新对象环境中调用构造函数使this指向新对象）
  fun.call(obj, ...args);
  // 4.返回对象
  return obj;
}
```

5. symbol 的作用

独一无二的命名，防止命名冲突，同时对象中的 symbol 键不会被常规的方法遍历到。Symbol.for 可以在全局访问 symbol。

6. 闭包是什么？

闭包指的是有权访问另一个函数作用域中的变量的函数。

7. 什么是作用域链？

当访问一个变量时，编译器在执行代码时会在当前作用域查找是否有这个标识符，如果没有找到则到父作用域中查找，直到找到最顶层为止。

8. 怎么理解原型链？

每个对象 A 上都有一个`[[prototype]]`属性(可以通过`__proto__`访问)，指向另一个对象 B，那么 B 就是 A 的原型。

对象可以访问原型上的属性和方法，当读取对象属性时，如果属性不存在，则会到原型上查找，而原型也可以访问自己原型的属性的方法，这样一种层层向上追溯的机制，构成了一条原型链。

原型的一些常用方法：

**枚举属性**

| 方法                            | 枚举属性范围         |
| ------------------------------- | -------------------- |
| Object.keys                     | 实例上，可枚举       |
| for(let prop in obj)            | 实例和原型上，可枚举 |
| Object.getOwnPropertyNames(obj) | 实例                 |
| prop in obj                     | 实例和原型上         |

**判断原型**

`isPrototypeOf`, `Object.getPrototypeOf`, `instanceof`

手写`instanceof`

```js
function myInstanceOf(left, right) {
  let proto = Object.getPrototypeOf(left);
  while (true) {
    if (proto === null) {
      return false;
    }
    if (proto === right.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
}
```

9. 防抖和节流，手写代码

防抖：短时间内重复调用，只会执行最后一次

```js
function debounce(func, time) {
  let timeout = null;
  return function (...args) {
    const context = this;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      func.apply(context, args);
      timeout = null;
    }, time);
  };
}
```

节流：短时间内重复调用，限制 n 秒最多执行一次

```js
function throttle(func, time) {
  let timeout = null;
  return function (...args) {
    const context = this;
    if (timeout) return;
    timeout = setTimeout(() => {
      func.apply(context, args);
      timeout = null;
    }, time);
  };
}
```

9. 手写数组 reduce 方法

```js
Array.prototype.myReduce = function (fun, init) {
  const list = [...this];
  let total = init !== undefined ? init : list[0];
  for (let i = 0; i < list.length; i++) {
    total = fun(total, list[i], i);
  }
  return total;
};
```

10. 手写 Function.call

```js
Function.prototype.myCall = function (context, ...args) {
  // 边界处理，基本类型没有this
  context = typeof context === "object" ? context : window;
  // 防止key冲突
  const key = Symbol();
  // 将this（当前函数）放到context中
  context[key] = this;
  // 在context中执行函数
  const res = context[key](...args);
  // 删除context的this
  delete context[key];
  // 返回结果
  return res;
};
```

### CSS

## 框架原理

### React

### Vue

## 前端工程化

## 浏览器特性

1. 事件流

三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

DOM 0 级事件：onclick

DOM 2 级事件：addEventListener

DOM 3 级事件：增加了事件类型，如 UI 事件、焦点事件、鼠标事件

## 算法

## 项目相关

## 其它
