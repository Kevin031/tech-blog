# 面试八股文大纲

以下题目仅描述思路

## 语言原理

### JS

1. **0.1+0.2==0.3 吗，为什么？**

小数进制转换和对阶运算导致的精度丢失。解决思路：通过字符串自己实现运算逻辑，或者在小数位已知的前提下转换成整数运算。

2. JS 数据类型

基本类型：Number, Boolean, String, null, undefined, symbol, BigInt

引用类型：Object（对象子类型 Array, Function, Map, Set）

引用类型和基本类型的区别：栈内存和堆内存

3. 如何实现对象深拷贝？

遍历对象，object 类型执行递归，基本类型直接赋值。

进阶：需考虑循环引用、函数、时间等类型

4. new 一个函数发生了什么？

创建一个新对象，新对象的`__proto__`指向构造函数 `prototype` 所引用的对象，新对象绑定函数的 `this`，如果函数没有返回值，就直接返回这个新对象

```js
function myNew(func, args) {
  // 1.新建一个空对象
  let obj = new Object();
  // 2.将构造函数的prototype指向新对象的__proto__
  obj.__proto__ = fun.prototype;
  // 3.改变this的指向（在新对象环境中调用构造函数使this指向新对象）
  fun.call(obj, ...args);
  // 4.返回对象
  return obj;
}
```

5. this 的指向问题，分别有哪几种情况？

全局：严格模式指向 undefined，非严格模式指向 window 或 global

函数：指向调用它的对象，如果找不到则指向全局

6. symbol 的作用

独一无二的命名，防止命名冲突，同时对象中的 symbol 键不会被常规的方法遍历到。Symbol.for 可以在全局访问 symbol。

7. 闭包是什么？如何产生？使用场景

闭包指的是有权访问另一个函数作用域中的变量的函数。

:::
MDN 定义：闭包是指那些可以访问自由变量的函数。
:::

何为自由变量，指的是在函数中使用，但既不是函数也不是函数局部变量的变量。

因此更权威的定义是：

```
闭包 = 函数 + 函数能访问的自由变量
```

从理论角度：

所有的函数在定义的时候就将执行上下文数据保存起来了，它的外部作用域的变量就变成了自由变量。

从实践角度，以下的两种情况形成了闭包：

- 1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
- 2. 在代码中引用了自由变量

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f;
}

var foo = checkscope();
foo();
```

在这个例子中，f 的执行上下文维护了一个作用域链：`[A0, checkscopeContext.AO, globalContext.VO]`，正因为这个作用域链的存在，f 读取到了 checkscope 中变量的值，即使 checkscopeContext 被销毁了，js 依然会让它的变量活跃在内存中，成为自由变量。

8. 什么是作用域链？作用域链是怎么产生的？

当访问一个变量时，编译器在执行代码时会在当前作用域查找是否有这个标识符，如果没有找到则到父作用域中查找，直到找到最顶层为止。

作用域链的产生是由于执行函数的时候会创建执行上下文，里面就包含了函数可以访问的作用域。

9. 函数的作用域是什么时候产生的？

JS 的函数是**静态作用域**，所以函数的作用域在定义的时候就确定了。

看个例子：

```js
var value = 1;
function foo() {
  console.log(value);
}
function bar() {
  var value = 2;
  foo();
}
bar(); // 输出1，因为作用域在定义的时候确定了
```

**词法作用域**：函数的作用域基于函数创建的位置

再看个例子：

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f;
}
checkscope()(); // 输出 local scope
```

引用《JavaScript 权威指南》的说法，js 函数执行的时候用访问到了作用域链，而作用域链正是在函数定义的时候产生的，因此不管何时执行函数，都会访问它创建的时候绑定的作用域。

10. var 和 function 的优先级谁更高？

如下例子：

```js
var foo = function () {
  console.log("1");
};
foo(); // 1
var foo = function () {
  console.log("2");
};
foo(); // 2
```

```js
function foo() {
  console.log("1");
}
foo(); // 2
function foo() {
  console.log("2");
}
foo(); // 2
```

这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候会先发生**变量提升**和**函数提升**。

当执行函数的时候，就会创建一个执行上下文，并且**压入执行上下文栈**，当函数执行完毕后，就会将函数的执行上下文从栈中弹出。

但是变量和函数的提升方式是有区别的

变量提升是先定义为 undefined，执行的时候才会赋值（例子 1 中的 function 是匿名函数）

函数提升是将函数体直接注册到全局，提升的时候如果有重名会进行**重载**

在上述例子 2 中，伪代码表示如下

```
ECStack.push(<fun1>, functionContext)
// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext)
// fun2还调用了fun3！
ECStack.push(<fun3> functionContext)

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();
```

11. 怎么理解原型链？

每个对象 A 上都有一个`[[prototype]]`属性(可以通过`__proto__`访问)，指向另一个对象 B，那么 B 就是 A 的原型。

对象可以访问原型上的属性和方法，当读取对象属性时，如果属性不存在，则会到原型上查找，而原型也可以访问自己原型的属性的方法，这样一种层层向上追溯的机制，构成了一条原型链。

原型的一些常用方法：

**枚举属性**

| 方法                            | 枚举属性范围         |
| ------------------------------- | -------------------- |
| Object.keys                     | 实例上，可枚举       |
| for(let prop in obj)            | 实例和原型上，可枚举 |
| Object.getOwnPropertyNames(obj) | 实例                 |
| prop in obj                     | 实例和原型上         |

**判断原型**

`isPrototypeOf`, `Object.getPrototypeOf`, `instanceof`

手写`instanceof`

```js
function myInstanceOf(left, right) {
  let proto = Object.getPrototypeOf(left);
  while (true) {
    if (proto === null) {
      return false;
    }
    if (proto === right.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
}
```

12. 防抖和节流，手写代码

防抖：短时间内重复调用，只会执行最后一次

```js
function debounce(func, time) {
  let timeout = null;
  return function (...args) {
    const context = this;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      func.apply(context, args);
      timeout = null;
    }, time);
  };
}
```

节流：短时间内重复调用，限制 n 秒最多执行一次

```js
function throttle(func, time) {
  let timeout = null;
  return function (...args) {
    const context = this;
    if (timeout) return;
    timeout = setTimeout(() => {
      func.apply(context, args);
      timeout = null;
    }, time);
  };
}
```

13. 手写数组 reduce 方法

```js
Array.prototype.myReduce = function (fun, init) {
  const list = [...this];
  let total = init !== undefined ? init : list[0];
  for (let i = 0; i < list.length; i++) {
    total = fun(total, list[i], i);
  }
  return total;
};
```

14. 手写 Function.call

易错点：key 冲突问题、未清空 key、未考虑基本类型

```js
Function.prototype.myCall = function (context, ...args) {
  // 判断调用myCall的是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Function.prototype.myCall - 被调用的对象必须是函数");
  }
  // 如果没有传入上下文对象，则默认为全局对象
  // ES11 引入了 globalThis，它是一个统一的全局对象
  // 无论在浏览器还是 Node.js 中，都可以使用 globalThis 来访问全局对象。
  if (context === null || context === undefined) {
    context = globalThis;
  } else {
    // 基本类型数字、字符串需要转成原始对象，避免下面调用context[key]报错
    context = Object(context);
  }
  // 防止key冲突
  const key = Symbol();
  // 将this（当前函数）放到context中
  context[key] = this;
  // 在context中执行函数
  const res = context[key](...args);
  // 删除context的this
  delete context[key];
  // 返回结果
  return res;
};
```

### CSS

## 框架原理

### React

### Vue

## 前端工程化

## 网络

1. http1.1 和 http2.0 的区别

2. https 和 http 的区别

https 就是在 http 的基础上加入了 ssl/tsl 验证

同时在传输过程中数据是加密的，这个过程中如果请求被运营商劫持了，没有公钥解密就不知道数据的真实内容，也无法篡改

它的流程如下：

```
1. TCP三次握手
2. 客户端向服务端请求数字证书
3. 客户端获取到数字证书，拿到里面的公钥生成摘要，然后和CA颁发的数字证书中的公钥进行比对确认**公钥无误**
4. 客户端向服务端请求会话使用的key，服务端生成临时key使用私钥加密后发给客户端，客户端使用第3步的公钥解密得到key
5. 客户端和服务端用前面的key开始对称加密通信
```

关于中间人攻击，就是指请求被代理劫持了，代理重新生成一组公钥和私钥，分别和客户端和服务端交换，客户端拿到的是中间人伪造的公钥，真正的公钥保存在中间人那里。而 CA 的存在相当于公证处，就是服务器把公钥提交给权威机构 CA，这样客户端可以从 CA 那里拿到可信的公钥进行比对，确保公钥没有被篡改过。

https 解决了三大问题：

窃听风险、篡改风险、冒充风险

3. 对 JWT 的理解

JWT 的组成方式是 `HEADER.PAYLOAD.signature`，它由服务端生成传给客户端，客户端将它保存在 localStorage 中，每次请求通过`Access-Token`或`Authrization`带上，用于身份验证。

`HEADER`: 头部信息的 `base64`，通常包含 `rsa` 类型

`PAYLOAD`: 数据内容的 `base64`，比如用户 ID，过期时间

`signature`: `HEADER`和`PAYLOAD`通过 `rsa` 算法加密得到的签名

其中 `rsa` 的密钥只存在服务端，当服务器接收到传过来的签名后，会根据`HEADER`和`PAYLOAD`重新计算出`signature`和客户端传过来的值进行比较，确认信息没有被篡改过。

JWT 可以弥补 `http` 无状态的问题，用于替代 cookie 的方案，用于用户身份的验证，同时也可以用于跨域场景。

`token` 建议保存到 `localStorage` 上，而不是 `cookie` 上，是因为 `cookie` 是明文传输的，容易被劫持，并且 `cookie` 通常有过期时间。

## 浏览器特性

1. 事件流

三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

DOM 0 级事件：onclick

DOM 2 级事件：addEventListener

DOM 3 级事件：增加了事件类型，如 UI 事件、焦点事件、鼠标事件

## 算法

## 项目相关

## 其它
